// Code generated by Prisma (prisma@1.31.1). DO NOT EDIT.
  // Please don't change this file manually but run `prisma generate` to update it.
  // For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

export const typeDefs = /* GraphQL */ `type Account {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  email: String!
  password: String!
  profile: Profile!
  role: Role!
}

type AccountConnection {
  pageInfo: PageInfo!
  edges: [AccountEdge]!
  aggregate: AggregateAccount!
}

input AccountCreateInput {
  id: ID
  email: String!
  password: String!
  profile: ProfileCreateOneWithoutAccountInput!
  role: Role!
}

input AccountCreateOneWithoutProfileInput {
  create: AccountCreateWithoutProfileInput
  connect: AccountWhereUniqueInput
}

input AccountCreateWithoutProfileInput {
  id: ID
  email: String!
  password: String!
  role: Role!
}

type AccountEdge {
  node: Account!
  cursor: String!
}

enum AccountOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
  email_ASC
  email_DESC
  password_ASC
  password_DESC
  role_ASC
  role_DESC
}

type AccountPreviousValues {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  email: String!
  password: String!
  role: Role!
}

type AccountSubscriptionPayload {
  mutation: MutationType!
  node: Account
  updatedFields: [String!]
  previousValues: AccountPreviousValues
}

input AccountSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: AccountWhereInput
  AND: [AccountSubscriptionWhereInput!]
  OR: [AccountSubscriptionWhereInput!]
  NOT: [AccountSubscriptionWhereInput!]
}

input AccountUpdateInput {
  email: String
  password: String
  profile: ProfileUpdateOneRequiredWithoutAccountInput
  role: Role
}

input AccountUpdateManyMutationInput {
  email: String
  password: String
  role: Role
}

input AccountUpdateOneRequiredWithoutProfileInput {
  create: AccountCreateWithoutProfileInput
  update: AccountUpdateWithoutProfileDataInput
  upsert: AccountUpsertWithoutProfileInput
  connect: AccountWhereUniqueInput
}

input AccountUpdateWithoutProfileDataInput {
  email: String
  password: String
  role: Role
}

input AccountUpsertWithoutProfileInput {
  update: AccountUpdateWithoutProfileDataInput!
  create: AccountCreateWithoutProfileInput!
}

input AccountWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  email: String
  email_not: String
  email_in: [String!]
  email_not_in: [String!]
  email_lt: String
  email_lte: String
  email_gt: String
  email_gte: String
  email_contains: String
  email_not_contains: String
  email_starts_with: String
  email_not_starts_with: String
  email_ends_with: String
  email_not_ends_with: String
  password: String
  password_not: String
  password_in: [String!]
  password_not_in: [String!]
  password_lt: String
  password_lte: String
  password_gt: String
  password_gte: String
  password_contains: String
  password_not_contains: String
  password_starts_with: String
  password_not_starts_with: String
  password_ends_with: String
  password_not_ends_with: String
  profile: ProfileWhereInput
  role: Role
  role_not: Role
  role_in: [Role!]
  role_not_in: [Role!]
  AND: [AccountWhereInput!]
  OR: [AccountWhereInput!]
  NOT: [AccountWhereInput!]
}

input AccountWhereUniqueInput {
  id: ID
  email: String
}

type AggregateAccount {
  count: Int!
}

type AggregateCourse {
  count: Int!
}

type AggregateGolfer {
  count: Int!
}

type AggregateHole {
  count: Int!
}

type AggregateProfile {
  count: Int!
}

type AggregateScorecard {
  count: Int!
}

type AggregateStroke {
  count: Int!
}

type BatchPayload {
  count: Long!
}

type Course {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  scoreCard: Scorecard!
  courseName: String!
  courseAddress: String!
  coursePhone: String!
  long: Float!
  lat: Float!
  numberOfHoles: Int!
  holes(where: HoleWhereInput, orderBy: HoleOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Hole!]
}

type CourseConnection {
  pageInfo: PageInfo!
  edges: [CourseEdge]!
  aggregate: AggregateCourse!
}

input CourseCreateInput {
  id: ID
  scoreCard: ScorecardCreateOneWithoutCourseInput!
  courseName: String!
  courseAddress: String!
  coursePhone: String!
  long: Float!
  lat: Float!
  numberOfHoles: Int!
  holes: HoleCreateManyWithoutCourseInput
}

input CourseCreateOneWithoutHolesInput {
  create: CourseCreateWithoutHolesInput
  connect: CourseWhereUniqueInput
}

input CourseCreateOneWithoutScoreCardInput {
  create: CourseCreateWithoutScoreCardInput
  connect: CourseWhereUniqueInput
}

input CourseCreateWithoutHolesInput {
  id: ID
  scoreCard: ScorecardCreateOneWithoutCourseInput!
  courseName: String!
  courseAddress: String!
  coursePhone: String!
  long: Float!
  lat: Float!
  numberOfHoles: Int!
}

input CourseCreateWithoutScoreCardInput {
  id: ID
  courseName: String!
  courseAddress: String!
  coursePhone: String!
  long: Float!
  lat: Float!
  numberOfHoles: Int!
  holes: HoleCreateManyWithoutCourseInput
}

type CourseEdge {
  node: Course!
  cursor: String!
}

enum CourseOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
  courseName_ASC
  courseName_DESC
  courseAddress_ASC
  courseAddress_DESC
  coursePhone_ASC
  coursePhone_DESC
  long_ASC
  long_DESC
  lat_ASC
  lat_DESC
  numberOfHoles_ASC
  numberOfHoles_DESC
}

type CoursePreviousValues {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  courseName: String!
  courseAddress: String!
  coursePhone: String!
  long: Float!
  lat: Float!
  numberOfHoles: Int!
}

type CourseSubscriptionPayload {
  mutation: MutationType!
  node: Course
  updatedFields: [String!]
  previousValues: CoursePreviousValues
}

input CourseSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: CourseWhereInput
  AND: [CourseSubscriptionWhereInput!]
  OR: [CourseSubscriptionWhereInput!]
  NOT: [CourseSubscriptionWhereInput!]
}

input CourseUpdateInput {
  scoreCard: ScorecardUpdateOneRequiredWithoutCourseInput
  courseName: String
  courseAddress: String
  coursePhone: String
  long: Float
  lat: Float
  numberOfHoles: Int
  holes: HoleUpdateManyWithoutCourseInput
}

input CourseUpdateManyMutationInput {
  courseName: String
  courseAddress: String
  coursePhone: String
  long: Float
  lat: Float
  numberOfHoles: Int
}

input CourseUpdateOneRequiredWithoutHolesInput {
  create: CourseCreateWithoutHolesInput
  update: CourseUpdateWithoutHolesDataInput
  upsert: CourseUpsertWithoutHolesInput
  connect: CourseWhereUniqueInput
}

input CourseUpdateOneRequiredWithoutScoreCardInput {
  create: CourseCreateWithoutScoreCardInput
  update: CourseUpdateWithoutScoreCardDataInput
  upsert: CourseUpsertWithoutScoreCardInput
  connect: CourseWhereUniqueInput
}

input CourseUpdateWithoutHolesDataInput {
  scoreCard: ScorecardUpdateOneRequiredWithoutCourseInput
  courseName: String
  courseAddress: String
  coursePhone: String
  long: Float
  lat: Float
  numberOfHoles: Int
}

input CourseUpdateWithoutScoreCardDataInput {
  courseName: String
  courseAddress: String
  coursePhone: String
  long: Float
  lat: Float
  numberOfHoles: Int
  holes: HoleUpdateManyWithoutCourseInput
}

input CourseUpsertWithoutHolesInput {
  update: CourseUpdateWithoutHolesDataInput!
  create: CourseCreateWithoutHolesInput!
}

input CourseUpsertWithoutScoreCardInput {
  update: CourseUpdateWithoutScoreCardDataInput!
  create: CourseCreateWithoutScoreCardInput!
}

input CourseWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  scoreCard: ScorecardWhereInput
  courseName: String
  courseName_not: String
  courseName_in: [String!]
  courseName_not_in: [String!]
  courseName_lt: String
  courseName_lte: String
  courseName_gt: String
  courseName_gte: String
  courseName_contains: String
  courseName_not_contains: String
  courseName_starts_with: String
  courseName_not_starts_with: String
  courseName_ends_with: String
  courseName_not_ends_with: String
  courseAddress: String
  courseAddress_not: String
  courseAddress_in: [String!]
  courseAddress_not_in: [String!]
  courseAddress_lt: String
  courseAddress_lte: String
  courseAddress_gt: String
  courseAddress_gte: String
  courseAddress_contains: String
  courseAddress_not_contains: String
  courseAddress_starts_with: String
  courseAddress_not_starts_with: String
  courseAddress_ends_with: String
  courseAddress_not_ends_with: String
  coursePhone: String
  coursePhone_not: String
  coursePhone_in: [String!]
  coursePhone_not_in: [String!]
  coursePhone_lt: String
  coursePhone_lte: String
  coursePhone_gt: String
  coursePhone_gte: String
  coursePhone_contains: String
  coursePhone_not_contains: String
  coursePhone_starts_with: String
  coursePhone_not_starts_with: String
  coursePhone_ends_with: String
  coursePhone_not_ends_with: String
  long: Float
  long_not: Float
  long_in: [Float!]
  long_not_in: [Float!]
  long_lt: Float
  long_lte: Float
  long_gt: Float
  long_gte: Float
  lat: Float
  lat_not: Float
  lat_in: [Float!]
  lat_not_in: [Float!]
  lat_lt: Float
  lat_lte: Float
  lat_gt: Float
  lat_gte: Float
  numberOfHoles: Int
  numberOfHoles_not: Int
  numberOfHoles_in: [Int!]
  numberOfHoles_not_in: [Int!]
  numberOfHoles_lt: Int
  numberOfHoles_lte: Int
  numberOfHoles_gt: Int
  numberOfHoles_gte: Int
  holes_every: HoleWhereInput
  holes_some: HoleWhereInput
  holes_none: HoleWhereInput
  AND: [CourseWhereInput!]
  OR: [CourseWhereInput!]
  NOT: [CourseWhereInput!]
}

input CourseWhereUniqueInput {
  id: ID
}

scalar DateTime

type Golfer {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  name: String!
  scoreCard: Scorecard
}

type GolferConnection {
  pageInfo: PageInfo!
  edges: [GolferEdge]!
  aggregate: AggregateGolfer!
}

input GolferCreateInput {
  id: ID
  name: String!
  scoreCard: ScorecardCreateOneWithoutGolfersInput
}

input GolferCreateManyWithoutScoreCardInput {
  create: [GolferCreateWithoutScoreCardInput!]
  connect: [GolferWhereUniqueInput!]
}

input GolferCreateWithoutScoreCardInput {
  id: ID
  name: String!
}

type GolferEdge {
  node: Golfer!
  cursor: String!
}

enum GolferOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
  name_ASC
  name_DESC
}

type GolferPreviousValues {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  name: String!
}

input GolferScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  AND: [GolferScalarWhereInput!]
  OR: [GolferScalarWhereInput!]
  NOT: [GolferScalarWhereInput!]
}

type GolferSubscriptionPayload {
  mutation: MutationType!
  node: Golfer
  updatedFields: [String!]
  previousValues: GolferPreviousValues
}

input GolferSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: GolferWhereInput
  AND: [GolferSubscriptionWhereInput!]
  OR: [GolferSubscriptionWhereInput!]
  NOT: [GolferSubscriptionWhereInput!]
}

input GolferUpdateInput {
  name: String
  scoreCard: ScorecardUpdateOneWithoutGolfersInput
}

input GolferUpdateManyDataInput {
  name: String
}

input GolferUpdateManyMutationInput {
  name: String
}

input GolferUpdateManyWithoutScoreCardInput {
  create: [GolferCreateWithoutScoreCardInput!]
  delete: [GolferWhereUniqueInput!]
  connect: [GolferWhereUniqueInput!]
  set: [GolferWhereUniqueInput!]
  disconnect: [GolferWhereUniqueInput!]
  update: [GolferUpdateWithWhereUniqueWithoutScoreCardInput!]
  upsert: [GolferUpsertWithWhereUniqueWithoutScoreCardInput!]
  deleteMany: [GolferScalarWhereInput!]
  updateMany: [GolferUpdateManyWithWhereNestedInput!]
}

input GolferUpdateManyWithWhereNestedInput {
  where: GolferScalarWhereInput!
  data: GolferUpdateManyDataInput!
}

input GolferUpdateWithoutScoreCardDataInput {
  name: String
}

input GolferUpdateWithWhereUniqueWithoutScoreCardInput {
  where: GolferWhereUniqueInput!
  data: GolferUpdateWithoutScoreCardDataInput!
}

input GolferUpsertWithWhereUniqueWithoutScoreCardInput {
  where: GolferWhereUniqueInput!
  update: GolferUpdateWithoutScoreCardDataInput!
  create: GolferCreateWithoutScoreCardInput!
}

input GolferWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  scoreCard: ScorecardWhereInput
  AND: [GolferWhereInput!]
  OR: [GolferWhereInput!]
  NOT: [GolferWhereInput!]
}

input GolferWhereUniqueInput {
  id: ID
}

type Hole {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  course: Course!
  holeNum: Int!
  handicap: Int!
  par: Int!
  distanceToFlag: Float!
  blueTee: Int
  whiteTee: Int
  redTee: Int
}

type HoleConnection {
  pageInfo: PageInfo!
  edges: [HoleEdge]!
  aggregate: AggregateHole!
}

input HoleCreateInput {
  id: ID
  course: CourseCreateOneWithoutHolesInput!
  holeNum: Int!
  handicap: Int!
  par: Int!
  distanceToFlag: Float!
  blueTee: Int
  whiteTee: Int
  redTee: Int
}

input HoleCreateManyWithoutCourseInput {
  create: [HoleCreateWithoutCourseInput!]
  connect: [HoleWhereUniqueInput!]
}

input HoleCreateOneInput {
  create: HoleCreateInput
  connect: HoleWhereUniqueInput
}

input HoleCreateWithoutCourseInput {
  id: ID
  holeNum: Int!
  handicap: Int!
  par: Int!
  distanceToFlag: Float!
  blueTee: Int
  whiteTee: Int
  redTee: Int
}

type HoleEdge {
  node: Hole!
  cursor: String!
}

enum HoleOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
  holeNum_ASC
  holeNum_DESC
  handicap_ASC
  handicap_DESC
  par_ASC
  par_DESC
  distanceToFlag_ASC
  distanceToFlag_DESC
  blueTee_ASC
  blueTee_DESC
  whiteTee_ASC
  whiteTee_DESC
  redTee_ASC
  redTee_DESC
}

type HolePreviousValues {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  holeNum: Int!
  handicap: Int!
  par: Int!
  distanceToFlag: Float!
  blueTee: Int
  whiteTee: Int
  redTee: Int
}

input HoleScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  holeNum: Int
  holeNum_not: Int
  holeNum_in: [Int!]
  holeNum_not_in: [Int!]
  holeNum_lt: Int
  holeNum_lte: Int
  holeNum_gt: Int
  holeNum_gte: Int
  handicap: Int
  handicap_not: Int
  handicap_in: [Int!]
  handicap_not_in: [Int!]
  handicap_lt: Int
  handicap_lte: Int
  handicap_gt: Int
  handicap_gte: Int
  par: Int
  par_not: Int
  par_in: [Int!]
  par_not_in: [Int!]
  par_lt: Int
  par_lte: Int
  par_gt: Int
  par_gte: Int
  distanceToFlag: Float
  distanceToFlag_not: Float
  distanceToFlag_in: [Float!]
  distanceToFlag_not_in: [Float!]
  distanceToFlag_lt: Float
  distanceToFlag_lte: Float
  distanceToFlag_gt: Float
  distanceToFlag_gte: Float
  blueTee: Int
  blueTee_not: Int
  blueTee_in: [Int!]
  blueTee_not_in: [Int!]
  blueTee_lt: Int
  blueTee_lte: Int
  blueTee_gt: Int
  blueTee_gte: Int
  whiteTee: Int
  whiteTee_not: Int
  whiteTee_in: [Int!]
  whiteTee_not_in: [Int!]
  whiteTee_lt: Int
  whiteTee_lte: Int
  whiteTee_gt: Int
  whiteTee_gte: Int
  redTee: Int
  redTee_not: Int
  redTee_in: [Int!]
  redTee_not_in: [Int!]
  redTee_lt: Int
  redTee_lte: Int
  redTee_gt: Int
  redTee_gte: Int
  AND: [HoleScalarWhereInput!]
  OR: [HoleScalarWhereInput!]
  NOT: [HoleScalarWhereInput!]
}

type HoleSubscriptionPayload {
  mutation: MutationType!
  node: Hole
  updatedFields: [String!]
  previousValues: HolePreviousValues
}

input HoleSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: HoleWhereInput
  AND: [HoleSubscriptionWhereInput!]
  OR: [HoleSubscriptionWhereInput!]
  NOT: [HoleSubscriptionWhereInput!]
}

input HoleUpdateDataInput {
  course: CourseUpdateOneRequiredWithoutHolesInput
  holeNum: Int
  handicap: Int
  par: Int
  distanceToFlag: Float
  blueTee: Int
  whiteTee: Int
  redTee: Int
}

input HoleUpdateInput {
  course: CourseUpdateOneRequiredWithoutHolesInput
  holeNum: Int
  handicap: Int
  par: Int
  distanceToFlag: Float
  blueTee: Int
  whiteTee: Int
  redTee: Int
}

input HoleUpdateManyDataInput {
  holeNum: Int
  handicap: Int
  par: Int
  distanceToFlag: Float
  blueTee: Int
  whiteTee: Int
  redTee: Int
}

input HoleUpdateManyMutationInput {
  holeNum: Int
  handicap: Int
  par: Int
  distanceToFlag: Float
  blueTee: Int
  whiteTee: Int
  redTee: Int
}

input HoleUpdateManyWithoutCourseInput {
  create: [HoleCreateWithoutCourseInput!]
  delete: [HoleWhereUniqueInput!]
  connect: [HoleWhereUniqueInput!]
  set: [HoleWhereUniqueInput!]
  disconnect: [HoleWhereUniqueInput!]
  update: [HoleUpdateWithWhereUniqueWithoutCourseInput!]
  upsert: [HoleUpsertWithWhereUniqueWithoutCourseInput!]
  deleteMany: [HoleScalarWhereInput!]
  updateMany: [HoleUpdateManyWithWhereNestedInput!]
}

input HoleUpdateManyWithWhereNestedInput {
  where: HoleScalarWhereInput!
  data: HoleUpdateManyDataInput!
}

input HoleUpdateOneRequiredInput {
  create: HoleCreateInput
  update: HoleUpdateDataInput
  upsert: HoleUpsertNestedInput
  connect: HoleWhereUniqueInput
}

input HoleUpdateWithoutCourseDataInput {
  holeNum: Int
  handicap: Int
  par: Int
  distanceToFlag: Float
  blueTee: Int
  whiteTee: Int
  redTee: Int
}

input HoleUpdateWithWhereUniqueWithoutCourseInput {
  where: HoleWhereUniqueInput!
  data: HoleUpdateWithoutCourseDataInput!
}

input HoleUpsertNestedInput {
  update: HoleUpdateDataInput!
  create: HoleCreateInput!
}

input HoleUpsertWithWhereUniqueWithoutCourseInput {
  where: HoleWhereUniqueInput!
  update: HoleUpdateWithoutCourseDataInput!
  create: HoleCreateWithoutCourseInput!
}

input HoleWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  course: CourseWhereInput
  holeNum: Int
  holeNum_not: Int
  holeNum_in: [Int!]
  holeNum_not_in: [Int!]
  holeNum_lt: Int
  holeNum_lte: Int
  holeNum_gt: Int
  holeNum_gte: Int
  handicap: Int
  handicap_not: Int
  handicap_in: [Int!]
  handicap_not_in: [Int!]
  handicap_lt: Int
  handicap_lte: Int
  handicap_gt: Int
  handicap_gte: Int
  par: Int
  par_not: Int
  par_in: [Int!]
  par_not_in: [Int!]
  par_lt: Int
  par_lte: Int
  par_gt: Int
  par_gte: Int
  distanceToFlag: Float
  distanceToFlag_not: Float
  distanceToFlag_in: [Float!]
  distanceToFlag_not_in: [Float!]
  distanceToFlag_lt: Float
  distanceToFlag_lte: Float
  distanceToFlag_gt: Float
  distanceToFlag_gte: Float
  blueTee: Int
  blueTee_not: Int
  blueTee_in: [Int!]
  blueTee_not_in: [Int!]
  blueTee_lt: Int
  blueTee_lte: Int
  blueTee_gt: Int
  blueTee_gte: Int
  whiteTee: Int
  whiteTee_not: Int
  whiteTee_in: [Int!]
  whiteTee_not_in: [Int!]
  whiteTee_lt: Int
  whiteTee_lte: Int
  whiteTee_gt: Int
  whiteTee_gte: Int
  redTee: Int
  redTee_not: Int
  redTee_in: [Int!]
  redTee_not_in: [Int!]
  redTee_lt: Int
  redTee_lte: Int
  redTee_gt: Int
  redTee_gte: Int
  AND: [HoleWhereInput!]
  OR: [HoleWhereInput!]
  NOT: [HoleWhereInput!]
}

input HoleWhereUniqueInput {
  id: ID
}

scalar Long

type Mutation {
  createAccount(data: AccountCreateInput!): Account!
  updateAccount(data: AccountUpdateInput!, where: AccountWhereUniqueInput!): Account
  updateManyAccounts(data: AccountUpdateManyMutationInput!, where: AccountWhereInput): BatchPayload!
  upsertAccount(where: AccountWhereUniqueInput!, create: AccountCreateInput!, update: AccountUpdateInput!): Account!
  deleteAccount(where: AccountWhereUniqueInput!): Account
  deleteManyAccounts(where: AccountWhereInput): BatchPayload!
  createCourse(data: CourseCreateInput!): Course!
  updateCourse(data: CourseUpdateInput!, where: CourseWhereUniqueInput!): Course
  updateManyCourses(data: CourseUpdateManyMutationInput!, where: CourseWhereInput): BatchPayload!
  upsertCourse(where: CourseWhereUniqueInput!, create: CourseCreateInput!, update: CourseUpdateInput!): Course!
  deleteCourse(where: CourseWhereUniqueInput!): Course
  deleteManyCourses(where: CourseWhereInput): BatchPayload!
  createGolfer(data: GolferCreateInput!): Golfer!
  updateGolfer(data: GolferUpdateInput!, where: GolferWhereUniqueInput!): Golfer
  updateManyGolfers(data: GolferUpdateManyMutationInput!, where: GolferWhereInput): BatchPayload!
  upsertGolfer(where: GolferWhereUniqueInput!, create: GolferCreateInput!, update: GolferUpdateInput!): Golfer!
  deleteGolfer(where: GolferWhereUniqueInput!): Golfer
  deleteManyGolfers(where: GolferWhereInput): BatchPayload!
  createHole(data: HoleCreateInput!): Hole!
  updateHole(data: HoleUpdateInput!, where: HoleWhereUniqueInput!): Hole
  updateManyHoles(data: HoleUpdateManyMutationInput!, where: HoleWhereInput): BatchPayload!
  upsertHole(where: HoleWhereUniqueInput!, create: HoleCreateInput!, update: HoleUpdateInput!): Hole!
  deleteHole(where: HoleWhereUniqueInput!): Hole
  deleteManyHoles(where: HoleWhereInput): BatchPayload!
  createProfile(data: ProfileCreateInput!): Profile!
  updateProfile(data: ProfileUpdateInput!, where: ProfileWhereUniqueInput!): Profile
  updateManyProfiles(data: ProfileUpdateManyMutationInput!, where: ProfileWhereInput): BatchPayload!
  upsertProfile(where: ProfileWhereUniqueInput!, create: ProfileCreateInput!, update: ProfileUpdateInput!): Profile!
  deleteProfile(where: ProfileWhereUniqueInput!): Profile
  deleteManyProfiles(where: ProfileWhereInput): BatchPayload!
  createScorecard(data: ScorecardCreateInput!): Scorecard!
  updateScorecard(data: ScorecardUpdateInput!, where: ScorecardWhereUniqueInput!): Scorecard
  upsertScorecard(where: ScorecardWhereUniqueInput!, create: ScorecardCreateInput!, update: ScorecardUpdateInput!): Scorecard!
  deleteScorecard(where: ScorecardWhereUniqueInput!): Scorecard
  deleteManyScorecards(where: ScorecardWhereInput): BatchPayload!
  createStroke(data: StrokeCreateInput!): Stroke!
  updateStroke(data: StrokeUpdateInput!, where: StrokeWhereUniqueInput!): Stroke
  updateManyStrokes(data: StrokeUpdateManyMutationInput!, where: StrokeWhereInput): BatchPayload!
  upsertStroke(where: StrokeWhereUniqueInput!, create: StrokeCreateInput!, update: StrokeUpdateInput!): Stroke!
  deleteStroke(where: StrokeWhereUniqueInput!): Stroke
  deleteManyStrokes(where: StrokeWhereInput): BatchPayload!
}

enum MutationType {
  CREATED
  UPDATED
  DELETED
}

interface Node {
  id: ID!
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
  endCursor: String
}

type Profile {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  firstName: String!
  lastName: String!
  fullName: String!
  account: Account!
  scoreCards(where: ScorecardWhereInput, orderBy: ScorecardOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Scorecard!]
}

type ProfileConnection {
  pageInfo: PageInfo!
  edges: [ProfileEdge]!
  aggregate: AggregateProfile!
}

input ProfileCreateInput {
  id: ID
  firstName: String!
  lastName: String!
  fullName: String!
  account: AccountCreateOneWithoutProfileInput!
  scoreCards: ScorecardCreateManyWithoutProfileInput
}

input ProfileCreateOneWithoutAccountInput {
  create: ProfileCreateWithoutAccountInput
  connect: ProfileWhereUniqueInput
}

input ProfileCreateOneWithoutScoreCardsInput {
  create: ProfileCreateWithoutScoreCardsInput
  connect: ProfileWhereUniqueInput
}

input ProfileCreateWithoutAccountInput {
  id: ID
  firstName: String!
  lastName: String!
  fullName: String!
  scoreCards: ScorecardCreateManyWithoutProfileInput
}

input ProfileCreateWithoutScoreCardsInput {
  id: ID
  firstName: String!
  lastName: String!
  fullName: String!
  account: AccountCreateOneWithoutProfileInput!
}

type ProfileEdge {
  node: Profile!
  cursor: String!
}

enum ProfileOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
  firstName_ASC
  firstName_DESC
  lastName_ASC
  lastName_DESC
  fullName_ASC
  fullName_DESC
}

type ProfilePreviousValues {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  firstName: String!
  lastName: String!
  fullName: String!
}

type ProfileSubscriptionPayload {
  mutation: MutationType!
  node: Profile
  updatedFields: [String!]
  previousValues: ProfilePreviousValues
}

input ProfileSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ProfileWhereInput
  AND: [ProfileSubscriptionWhereInput!]
  OR: [ProfileSubscriptionWhereInput!]
  NOT: [ProfileSubscriptionWhereInput!]
}

input ProfileUpdateInput {
  firstName: String
  lastName: String
  fullName: String
  account: AccountUpdateOneRequiredWithoutProfileInput
  scoreCards: ScorecardUpdateManyWithoutProfileInput
}

input ProfileUpdateManyMutationInput {
  firstName: String
  lastName: String
  fullName: String
}

input ProfileUpdateOneRequiredWithoutAccountInput {
  create: ProfileCreateWithoutAccountInput
  update: ProfileUpdateWithoutAccountDataInput
  upsert: ProfileUpsertWithoutAccountInput
  connect: ProfileWhereUniqueInput
}

input ProfileUpdateOneRequiredWithoutScoreCardsInput {
  create: ProfileCreateWithoutScoreCardsInput
  update: ProfileUpdateWithoutScoreCardsDataInput
  upsert: ProfileUpsertWithoutScoreCardsInput
  connect: ProfileWhereUniqueInput
}

input ProfileUpdateWithoutAccountDataInput {
  firstName: String
  lastName: String
  fullName: String
  scoreCards: ScorecardUpdateManyWithoutProfileInput
}

input ProfileUpdateWithoutScoreCardsDataInput {
  firstName: String
  lastName: String
  fullName: String
  account: AccountUpdateOneRequiredWithoutProfileInput
}

input ProfileUpsertWithoutAccountInput {
  update: ProfileUpdateWithoutAccountDataInput!
  create: ProfileCreateWithoutAccountInput!
}

input ProfileUpsertWithoutScoreCardsInput {
  update: ProfileUpdateWithoutScoreCardsDataInput!
  create: ProfileCreateWithoutScoreCardsInput!
}

input ProfileWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  firstName: String
  firstName_not: String
  firstName_in: [String!]
  firstName_not_in: [String!]
  firstName_lt: String
  firstName_lte: String
  firstName_gt: String
  firstName_gte: String
  firstName_contains: String
  firstName_not_contains: String
  firstName_starts_with: String
  firstName_not_starts_with: String
  firstName_ends_with: String
  firstName_not_ends_with: String
  lastName: String
  lastName_not: String
  lastName_in: [String!]
  lastName_not_in: [String!]
  lastName_lt: String
  lastName_lte: String
  lastName_gt: String
  lastName_gte: String
  lastName_contains: String
  lastName_not_contains: String
  lastName_starts_with: String
  lastName_not_starts_with: String
  lastName_ends_with: String
  lastName_not_ends_with: String
  fullName: String
  fullName_not: String
  fullName_in: [String!]
  fullName_not_in: [String!]
  fullName_lt: String
  fullName_lte: String
  fullName_gt: String
  fullName_gte: String
  fullName_contains: String
  fullName_not_contains: String
  fullName_starts_with: String
  fullName_not_starts_with: String
  fullName_ends_with: String
  fullName_not_ends_with: String
  account: AccountWhereInput
  scoreCards_every: ScorecardWhereInput
  scoreCards_some: ScorecardWhereInput
  scoreCards_none: ScorecardWhereInput
  AND: [ProfileWhereInput!]
  OR: [ProfileWhereInput!]
  NOT: [ProfileWhereInput!]
}

input ProfileWhereUniqueInput {
  id: ID
}

type Query {
  account(where: AccountWhereUniqueInput!): Account
  accounts(where: AccountWhereInput, orderBy: AccountOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Account]!
  accountsConnection(where: AccountWhereInput, orderBy: AccountOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): AccountConnection!
  course(where: CourseWhereUniqueInput!): Course
  courses(where: CourseWhereInput, orderBy: CourseOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Course]!
  coursesConnection(where: CourseWhereInput, orderBy: CourseOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): CourseConnection!
  golfer(where: GolferWhereUniqueInput!): Golfer
  golfers(where: GolferWhereInput, orderBy: GolferOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Golfer]!
  golfersConnection(where: GolferWhereInput, orderBy: GolferOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): GolferConnection!
  hole(where: HoleWhereUniqueInput!): Hole
  holes(where: HoleWhereInput, orderBy: HoleOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Hole]!
  holesConnection(where: HoleWhereInput, orderBy: HoleOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): HoleConnection!
  profile(where: ProfileWhereUniqueInput!): Profile
  profiles(where: ProfileWhereInput, orderBy: ProfileOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Profile]!
  profilesConnection(where: ProfileWhereInput, orderBy: ProfileOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ProfileConnection!
  scorecard(where: ScorecardWhereUniqueInput!): Scorecard
  scorecards(where: ScorecardWhereInput, orderBy: ScorecardOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Scorecard]!
  scorecardsConnection(where: ScorecardWhereInput, orderBy: ScorecardOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ScorecardConnection!
  stroke(where: StrokeWhereUniqueInput!): Stroke
  strokes(where: StrokeWhereInput, orderBy: StrokeOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Stroke]!
  strokesConnection(where: StrokeWhereInput, orderBy: StrokeOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): StrokeConnection!
  node(id: ID!): Node
}

enum Role {
  USER
  ADMIN
}

type Scorecard {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  profile: Profile!
  golfers(where: GolferWhereInput, orderBy: GolferOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Golfer!]
  course: Course!
  strokes(where: StrokeWhereInput, orderBy: StrokeOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Stroke!]
}

type ScorecardConnection {
  pageInfo: PageInfo!
  edges: [ScorecardEdge]!
  aggregate: AggregateScorecard!
}

input ScorecardCreateInput {
  id: ID
  profile: ProfileCreateOneWithoutScoreCardsInput!
  golfers: GolferCreateManyWithoutScoreCardInput
  course: CourseCreateOneWithoutScoreCardInput!
  strokes: StrokeCreateManyWithoutScoreCardInput
}

input ScorecardCreateManyWithoutProfileInput {
  create: [ScorecardCreateWithoutProfileInput!]
  connect: [ScorecardWhereUniqueInput!]
}

input ScorecardCreateOneWithoutCourseInput {
  create: ScorecardCreateWithoutCourseInput
  connect: ScorecardWhereUniqueInput
}

input ScorecardCreateOneWithoutGolfersInput {
  create: ScorecardCreateWithoutGolfersInput
  connect: ScorecardWhereUniqueInput
}

input ScorecardCreateOneWithoutStrokesInput {
  create: ScorecardCreateWithoutStrokesInput
  connect: ScorecardWhereUniqueInput
}

input ScorecardCreateWithoutCourseInput {
  id: ID
  profile: ProfileCreateOneWithoutScoreCardsInput!
  golfers: GolferCreateManyWithoutScoreCardInput
  strokes: StrokeCreateManyWithoutScoreCardInput
}

input ScorecardCreateWithoutGolfersInput {
  id: ID
  profile: ProfileCreateOneWithoutScoreCardsInput!
  course: CourseCreateOneWithoutScoreCardInput!
  strokes: StrokeCreateManyWithoutScoreCardInput
}

input ScorecardCreateWithoutProfileInput {
  id: ID
  golfers: GolferCreateManyWithoutScoreCardInput
  course: CourseCreateOneWithoutScoreCardInput!
  strokes: StrokeCreateManyWithoutScoreCardInput
}

input ScorecardCreateWithoutStrokesInput {
  id: ID
  profile: ProfileCreateOneWithoutScoreCardsInput!
  golfers: GolferCreateManyWithoutScoreCardInput
  course: CourseCreateOneWithoutScoreCardInput!
}

type ScorecardEdge {
  node: Scorecard!
  cursor: String!
}

enum ScorecardOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type ScorecardPreviousValues {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
}

input ScorecardScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [ScorecardScalarWhereInput!]
  OR: [ScorecardScalarWhereInput!]
  NOT: [ScorecardScalarWhereInput!]
}

type ScorecardSubscriptionPayload {
  mutation: MutationType!
  node: Scorecard
  updatedFields: [String!]
  previousValues: ScorecardPreviousValues
}

input ScorecardSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ScorecardWhereInput
  AND: [ScorecardSubscriptionWhereInput!]
  OR: [ScorecardSubscriptionWhereInput!]
  NOT: [ScorecardSubscriptionWhereInput!]
}

input ScorecardUpdateInput {
  profile: ProfileUpdateOneRequiredWithoutScoreCardsInput
  golfers: GolferUpdateManyWithoutScoreCardInput
  course: CourseUpdateOneRequiredWithoutScoreCardInput
  strokes: StrokeUpdateManyWithoutScoreCardInput
}

input ScorecardUpdateManyWithoutProfileInput {
  create: [ScorecardCreateWithoutProfileInput!]
  delete: [ScorecardWhereUniqueInput!]
  connect: [ScorecardWhereUniqueInput!]
  set: [ScorecardWhereUniqueInput!]
  disconnect: [ScorecardWhereUniqueInput!]
  update: [ScorecardUpdateWithWhereUniqueWithoutProfileInput!]
  upsert: [ScorecardUpsertWithWhereUniqueWithoutProfileInput!]
  deleteMany: [ScorecardScalarWhereInput!]
}

input ScorecardUpdateOneRequiredWithoutCourseInput {
  create: ScorecardCreateWithoutCourseInput
  update: ScorecardUpdateWithoutCourseDataInput
  upsert: ScorecardUpsertWithoutCourseInput
  connect: ScorecardWhereUniqueInput
}

input ScorecardUpdateOneWithoutGolfersInput {
  create: ScorecardCreateWithoutGolfersInput
  update: ScorecardUpdateWithoutGolfersDataInput
  upsert: ScorecardUpsertWithoutGolfersInput
  delete: Boolean
  disconnect: Boolean
  connect: ScorecardWhereUniqueInput
}

input ScorecardUpdateOneWithoutStrokesInput {
  create: ScorecardCreateWithoutStrokesInput
  update: ScorecardUpdateWithoutStrokesDataInput
  upsert: ScorecardUpsertWithoutStrokesInput
  delete: Boolean
  disconnect: Boolean
  connect: ScorecardWhereUniqueInput
}

input ScorecardUpdateWithoutCourseDataInput {
  profile: ProfileUpdateOneRequiredWithoutScoreCardsInput
  golfers: GolferUpdateManyWithoutScoreCardInput
  strokes: StrokeUpdateManyWithoutScoreCardInput
}

input ScorecardUpdateWithoutGolfersDataInput {
  profile: ProfileUpdateOneRequiredWithoutScoreCardsInput
  course: CourseUpdateOneRequiredWithoutScoreCardInput
  strokes: StrokeUpdateManyWithoutScoreCardInput
}

input ScorecardUpdateWithoutProfileDataInput {
  golfers: GolferUpdateManyWithoutScoreCardInput
  course: CourseUpdateOneRequiredWithoutScoreCardInput
  strokes: StrokeUpdateManyWithoutScoreCardInput
}

input ScorecardUpdateWithoutStrokesDataInput {
  profile: ProfileUpdateOneRequiredWithoutScoreCardsInput
  golfers: GolferUpdateManyWithoutScoreCardInput
  course: CourseUpdateOneRequiredWithoutScoreCardInput
}

input ScorecardUpdateWithWhereUniqueWithoutProfileInput {
  where: ScorecardWhereUniqueInput!
  data: ScorecardUpdateWithoutProfileDataInput!
}

input ScorecardUpsertWithoutCourseInput {
  update: ScorecardUpdateWithoutCourseDataInput!
  create: ScorecardCreateWithoutCourseInput!
}

input ScorecardUpsertWithoutGolfersInput {
  update: ScorecardUpdateWithoutGolfersDataInput!
  create: ScorecardCreateWithoutGolfersInput!
}

input ScorecardUpsertWithoutStrokesInput {
  update: ScorecardUpdateWithoutStrokesDataInput!
  create: ScorecardCreateWithoutStrokesInput!
}

input ScorecardUpsertWithWhereUniqueWithoutProfileInput {
  where: ScorecardWhereUniqueInput!
  update: ScorecardUpdateWithoutProfileDataInput!
  create: ScorecardCreateWithoutProfileInput!
}

input ScorecardWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  profile: ProfileWhereInput
  golfers_every: GolferWhereInput
  golfers_some: GolferWhereInput
  golfers_none: GolferWhereInput
  course: CourseWhereInput
  strokes_every: StrokeWhereInput
  strokes_some: StrokeWhereInput
  strokes_none: StrokeWhereInput
  AND: [ScorecardWhereInput!]
  OR: [ScorecardWhereInput!]
  NOT: [ScorecardWhereInput!]
}

input ScorecardWhereUniqueInput {
  id: ID
}

type Stroke {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  golferId: ID
  profileId: ID
  hole: Hole!
  scoreCard: Scorecard
  strokes: Int!
}

type StrokeConnection {
  pageInfo: PageInfo!
  edges: [StrokeEdge]!
  aggregate: AggregateStroke!
}

input StrokeCreateInput {
  id: ID
  golferId: ID
  profileId: ID
  hole: HoleCreateOneInput!
  scoreCard: ScorecardCreateOneWithoutStrokesInput
  strokes: Int!
}

input StrokeCreateManyWithoutScoreCardInput {
  create: [StrokeCreateWithoutScoreCardInput!]
  connect: [StrokeWhereUniqueInput!]
}

input StrokeCreateWithoutScoreCardInput {
  id: ID
  golferId: ID
  profileId: ID
  hole: HoleCreateOneInput!
  strokes: Int!
}

type StrokeEdge {
  node: Stroke!
  cursor: String!
}

enum StrokeOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
  golferId_ASC
  golferId_DESC
  profileId_ASC
  profileId_DESC
  strokes_ASC
  strokes_DESC
}

type StrokePreviousValues {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  golferId: ID
  profileId: ID
  strokes: Int!
}

input StrokeScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  golferId: ID
  golferId_not: ID
  golferId_in: [ID!]
  golferId_not_in: [ID!]
  golferId_lt: ID
  golferId_lte: ID
  golferId_gt: ID
  golferId_gte: ID
  golferId_contains: ID
  golferId_not_contains: ID
  golferId_starts_with: ID
  golferId_not_starts_with: ID
  golferId_ends_with: ID
  golferId_not_ends_with: ID
  profileId: ID
  profileId_not: ID
  profileId_in: [ID!]
  profileId_not_in: [ID!]
  profileId_lt: ID
  profileId_lte: ID
  profileId_gt: ID
  profileId_gte: ID
  profileId_contains: ID
  profileId_not_contains: ID
  profileId_starts_with: ID
  profileId_not_starts_with: ID
  profileId_ends_with: ID
  profileId_not_ends_with: ID
  strokes: Int
  strokes_not: Int
  strokes_in: [Int!]
  strokes_not_in: [Int!]
  strokes_lt: Int
  strokes_lte: Int
  strokes_gt: Int
  strokes_gte: Int
  AND: [StrokeScalarWhereInput!]
  OR: [StrokeScalarWhereInput!]
  NOT: [StrokeScalarWhereInput!]
}

type StrokeSubscriptionPayload {
  mutation: MutationType!
  node: Stroke
  updatedFields: [String!]
  previousValues: StrokePreviousValues
}

input StrokeSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: StrokeWhereInput
  AND: [StrokeSubscriptionWhereInput!]
  OR: [StrokeSubscriptionWhereInput!]
  NOT: [StrokeSubscriptionWhereInput!]
}

input StrokeUpdateInput {
  golferId: ID
  profileId: ID
  hole: HoleUpdateOneRequiredInput
  scoreCard: ScorecardUpdateOneWithoutStrokesInput
  strokes: Int
}

input StrokeUpdateManyDataInput {
  golferId: ID
  profileId: ID
  strokes: Int
}

input StrokeUpdateManyMutationInput {
  golferId: ID
  profileId: ID
  strokes: Int
}

input StrokeUpdateManyWithoutScoreCardInput {
  create: [StrokeCreateWithoutScoreCardInput!]
  delete: [StrokeWhereUniqueInput!]
  connect: [StrokeWhereUniqueInput!]
  set: [StrokeWhereUniqueInput!]
  disconnect: [StrokeWhereUniqueInput!]
  update: [StrokeUpdateWithWhereUniqueWithoutScoreCardInput!]
  upsert: [StrokeUpsertWithWhereUniqueWithoutScoreCardInput!]
  deleteMany: [StrokeScalarWhereInput!]
  updateMany: [StrokeUpdateManyWithWhereNestedInput!]
}

input StrokeUpdateManyWithWhereNestedInput {
  where: StrokeScalarWhereInput!
  data: StrokeUpdateManyDataInput!
}

input StrokeUpdateWithoutScoreCardDataInput {
  golferId: ID
  profileId: ID
  hole: HoleUpdateOneRequiredInput
  strokes: Int
}

input StrokeUpdateWithWhereUniqueWithoutScoreCardInput {
  where: StrokeWhereUniqueInput!
  data: StrokeUpdateWithoutScoreCardDataInput!
}

input StrokeUpsertWithWhereUniqueWithoutScoreCardInput {
  where: StrokeWhereUniqueInput!
  update: StrokeUpdateWithoutScoreCardDataInput!
  create: StrokeCreateWithoutScoreCardInput!
}

input StrokeWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  golferId: ID
  golferId_not: ID
  golferId_in: [ID!]
  golferId_not_in: [ID!]
  golferId_lt: ID
  golferId_lte: ID
  golferId_gt: ID
  golferId_gte: ID
  golferId_contains: ID
  golferId_not_contains: ID
  golferId_starts_with: ID
  golferId_not_starts_with: ID
  golferId_ends_with: ID
  golferId_not_ends_with: ID
  profileId: ID
  profileId_not: ID
  profileId_in: [ID!]
  profileId_not_in: [ID!]
  profileId_lt: ID
  profileId_lte: ID
  profileId_gt: ID
  profileId_gte: ID
  profileId_contains: ID
  profileId_not_contains: ID
  profileId_starts_with: ID
  profileId_not_starts_with: ID
  profileId_ends_with: ID
  profileId_not_ends_with: ID
  hole: HoleWhereInput
  scoreCard: ScorecardWhereInput
  strokes: Int
  strokes_not: Int
  strokes_in: [Int!]
  strokes_not_in: [Int!]
  strokes_lt: Int
  strokes_lte: Int
  strokes_gt: Int
  strokes_gte: Int
  AND: [StrokeWhereInput!]
  OR: [StrokeWhereInput!]
  NOT: [StrokeWhereInput!]
}

input StrokeWhereUniqueInput {
  id: ID
}

type Subscription {
  account(where: AccountSubscriptionWhereInput): AccountSubscriptionPayload
  course(where: CourseSubscriptionWhereInput): CourseSubscriptionPayload
  golfer(where: GolferSubscriptionWhereInput): GolferSubscriptionPayload
  hole(where: HoleSubscriptionWhereInput): HoleSubscriptionPayload
  profile(where: ProfileSubscriptionWhereInput): ProfileSubscriptionPayload
  scorecard(where: ScorecardSubscriptionWhereInput): ScorecardSubscriptionPayload
  stroke(where: StrokeSubscriptionWhereInput): StrokeSubscriptionPayload
}
`